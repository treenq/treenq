package domain

import (
	"context"
	"log/slog"
	"time"

	tqsdk "github.com/treenq/treenq/pkg/sdk"
)

type Handler struct {
	db           Database
	githubClient GithubClient
	git          Git
	extractor    Extractor
	docker       DockerArtifactory
	kube         Kube

	kubeConfig string

	oauthProvider   OauthProvider
	jwtIssuer       JwtIssuer
	authRedirectUrl string
	authTtl         time.Duration

	l *slog.Logger
}

type RollbackDeploymentRequest struct {
	DeploymentID string `json:"deployment_id"`
}

type RollbackDeploymentResponse struct {
	DeploymentID string `json:"deployment_id"`
}

func NewHandler(
	db Database,
	githubClient GithubClient,
	git Git,
	extractor Extractor,
	docker DockerArtifactory,
	kube Kube,
	kubeConfig string,

	oauthProvider OauthProvider,
	jwtIssuer JwtIssuer,
	authRedirectUrl string,
	authTtl time.Duration,

	l *slog.Logger,
) *Handler {
	return &Handler{
		db:           db,
		githubClient: githubClient,
		git:          git,
		extractor:    extractor,
		docker:       docker,
		kube:         kube,

		kubeConfig: kubeConfig,

		oauthProvider:   oauthProvider,
		jwtIssuer:       jwtIssuer,
		authRedirectUrl: authRedirectUrl,
		authTtl:         authTtl,
		l:               l,
	}
}

func (h *Handler) RollbackDeployment(ctx context.Context, req RollbackDeploymentRequest) (RollbackDeploymentResponse, error) {
	profile, err := h.GetProfile(ctx, struct{}{})
	if err != nil {
		return RollbackDeploymentResponse{}, err // Consider vel.Error if appropriate
	}

	oldDeployment, dbErr := h.db.GetDeployment(ctx, req.DeploymentID)
	if dbErr != nil {
		// Consider wrapping dbErr in a vel.Error or returning a more specific error
		return RollbackDeploymentResponse{}, dbErr
	}

	repo, dbErr := h.db.GetRepoByID(ctx, profile.UserInfo.ID, oldDeployment.RepoID)
	if dbErr != nil {
		// Consider wrapping dbErr in a vel.Error
		return RollbackDeploymentResponse{}, dbErr
	}

	newDeployment := AppDeployment{
		// ID will be generated by db.SaveDeployment or should be generated here
		RepoID:           oldDeployment.RepoID,
		Space:            oldDeployment.Space, // Assuming Space is of type json.RawMessage or similar
		SHA:              oldDeployment.SHA,
		BuildTag:         oldDeployment.BuildTag, // This might need adjustment if build tags are unique per build
		UserDisplayName:  profile.UserInfo.DisplayName,
		Status:           STATUS_PENDING,       // Ensure STATUS_PENDING is defined
		RolledBackFromID: &oldDeployment.ID, // Pointer to string
		// CreatedAt and UpdatedAt will be set by the database or SaveDeployment
	}

	savedDeployment, dbErr := h.db.SaveDeployment(ctx, newDeployment)
	if dbErr != nil {
		// Consider wrapping dbErr in a vel.Error
		return RollbackDeploymentResponse{}, dbErr
	}

	// Assuming deployRepo handles its own errors and logging
	_, deployErr := h.deployRepo(ctx, profile.UserInfo.DisplayName, repo) // deployRepo might need adjustment if it expects different params for rollback
	if deployErr != nil {
		// Handle deployErr, potentially update deployment status to failed
		// This part needs careful error handling and status updates
		return RollbackDeploymentResponse{}, deployErr // Consider vel.Error
	}

	return RollbackDeploymentResponse{DeploymentID: savedDeployment.ID}, nil
}

const (
	STATUS_PENDING = "pending"
	// Define other statuses if they exist e.g. STATUS_FAILED, STATUS_SUCCESS
)

type AppDeployment struct {
	ID               string `json:"id"`
	RepoID           string `json:"repo_id"`
	Space            tqsdk.Space `json:"space"`
	SHA              string `json:"sha"`
	BuildTag         string `json:"build_tag"`
	UserDisplayName  string `json:"user_display_name"`
	Status           string `json:"status"`
	RolledBackFromID *string `json:"rolled_back_from_id,omitempty"` // Pointer to allow null
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

type Database interface {
	// User domain
	////////////////////////
	GetOrCreateUser(ctx context.Context, user UserInfo) (UserInfo, error)

	// Deployment domain
	// ////////////////
	SaveDeployment(ctx context.Context, def AppDeployment) (AppDeployment, error)
	UpdateDeployment(ctx context.Context, def AppDeployment) error
	GetDeployment(ctx context.Context, deploymentID string) (AppDeployment, error)
	GetDeploymentHistory(ctx context.Context, appID string) ([]AppDeployment, error)

	// Github repos domain
	// //////////////////////
	LinkGithub(ctx context.Context, installationID int, senderLogin string, repos []InstalledRepository) (string, error)
	SaveGithubRepos(ctx context.Context, installationID int, senderLogin string, repos []InstalledRepository) error
	RemoveGithubRepos(ctx context.Context, installationID int, repos []InstalledRepository) error
	GetGithubRepos(ctx context.Context, email string) ([]Repository, error)
	GetInstallationID(ctx context.Context, userID string) (string, int, error)
	SaveInstallation(ctx context.Context, userID string, githubID int) (string, error)
	ConnectRepo(ctx context.Context, userID, repoID, branchName string) (Repository, error)
	GetRepoByGithub(ctx context.Context, githubRepoID int) (Repository, error)
	GetRepoByID(ctx context.Context, userID, repoID string) (Repository, error)
	RepoIsConnected(ctx context.Context, repoID string) (bool, error)
}

type GithubClient interface {
	IssueAccessToken(installationID int) (string, error)
	GetUserInstallation(ctx context.Context, displayName string) (int, error)
	ListRepositories(ctx context.Context, installationID int) ([]Repository, error)
	GetBranches(ctx context.Context, installationID int, owner string, repoName string, fresh bool) ([]string, error)
}

type Git interface {
	Clone(url string, installationID int, repoID string, accesstoken string) (GitRepo, error)
}

type Extractor interface {
	ExtractConfig(repoDir string) (tqsdk.Space, error)
}

type DockerArtifactory interface {
	Image(args BuildArtifactRequest) Image
	Build(ctx context.Context, args BuildArtifactRequest, progress *ProgressBuf) (Image, error)
}

type Kube interface {
	DefineApp(ctx context.Context, id string, app tqsdk.Space, image Image) string
	Apply(ctx context.Context, rawConig, data string) error
}

type OauthProvider interface {
	AuthUrl(string) string
	ExchangeUser(ctx context.Context, code string) (UserInfo, error)
}

type JwtIssuer interface {
	GenerateJwtToken(claims map[string]any) (string, error)
}
